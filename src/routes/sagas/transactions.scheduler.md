

Допустим в блокчейне 100к блоков

> Основной скелулер транзакций
1. Выбираем ренж блоков (100к - 90к)
2. Выбираем вкл. ассеты (пускай 9 штук + эфир)
3. Смотрим есть ли ассет с приоритетом, если есть оставлям только его
4. Смотрим, загружены ли транзакции для каждого ассета и этого ренжа, если нет - добавляем таску в очередь
Таким образов в очереди образуется N задач, и только для данных, которых пока нет в нашей БД
5. Каждая задача грузит список транзакций, создавая в редуксе структуру, типа Hash: {..info, isLoaded: false} (метаинформация пока не загружена)
6. Скедулер ждет, когда всё не обновится - выбирает сл. ренж. Так же он контролирует сколько щас транзакций и может ждать пагинации

Задачи по загрузке списков транзакций идут с высоким приоритетом, на равне с балансами
Параллейно есть еще один скедулер, который выбирает транзакции, по которым пока нет метаинформации и подгружает ее (+3 запроса)
Его запросы не приоритетны и идут постоянно.

> Описание ренжа

```
type BlockRange = Array<{
  start: number,
  end: number,
  assets: {
    [AssetAddeess]: Array<{
      start?: number,
      end?: number,
      isLoaded: boolean
    }>
  }
}>
```

Ренж предсталяет собой простую структуру в виде массива start-end-assets. Внутри ассета есть свой ренж. Изначально он равен родительскому.
Если транзакций у ассета много, и getTransactons(asset) отваливается по таймауту - он может быть разбит пополам и так до тех пор,
пока его размер не станет равен 1 блоку.
Основной ренж создается скедулером, сабренжи у ассетов создаются когда возникают ошибки getTransactons
